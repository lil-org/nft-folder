{
  "kind" : "p5js100",
  "screensaverFileName" : "ATOMS",
  "value" : "var seed = parseInt(tokenData.hash.slice(0, 16), 16);\n\np5.disableFriendlyErrors = true;\n\nlet pg;\n\nlet A, B;\nlet A1, A2, A3, A4;\nlet B1, B2, B3, B4;\nlet D1, D2;\n\nlet xx, yy;\n\nlet imageDim = 400;\nlet imageLength = imageDim * imageDim;\nlet signalHeight;\nlet numBlocks = imageDim\/4;\n\nlet lastBlockTime = 0;\nlet blockDelay = 375;\n\nlet dotsDensity = 36;\n\nlet signalIndex = imageDim * 4;\nlet blockIndex = 0;\n\nlet drawSignals = true;\nlet drawImage = true;\nlet drawBlocks = true;\nlet drawDots = true;\n\nlet angle = 0.0;\nlet angleSpeed = 0.01;\n\nlet newImgData = [];\n\nlet boff = 0;\n\nlet ratio = 0.0;\n\n\/\/ Features\nlet weirdo = false;\nlet doubleWaves = false;\nlet wave1 = -1;\nlet wave2 = -1;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight, WEBGL);\n  colorMode(HSB, 360, 100, 100);\n  \n  r = new RND(seed);\n  \n  \/\/ BEGIN features\n  if (r.rb(0, 1) > 0.95) {\n    weirdo = true;\n  }\n  if (r.rb(0, 1) > 0.6) {\n    doubleWaves = true;\n  }\n  wave1 = int(r.rb(1, 3));\n  wave2 = int(r.rb(1, 3));\n  \/\/ END features\n  \n  generateRandImage();\n  rectMode(CENTER);\n  imageMode(CENTER);\n  setDimensions();\n  frameRate(30);\n}\n\nfunction draw() {\n  if (weirdo) {\n    background(newImgData[blockIndex], 80, 100);\n  } else {\n    background(6, 15, 23+boff);\n  }\n\n  if (drawBlocks) { blocks(); }\n  if (drawSignals) { signals(); }\n  if (drawDots) { dots(); }\n  \n  if (drawImage) {\n    image(pg, A2, B2, D1, D1);\n  }\n  signalIndex += 4;\n  blockIndex += 2;\n  if (signalIndex > pg.pixels.length) {\n    signalIndex = imageDim * 4;\n  }\n  if (blockIndex > newImgData.length) {\n    blockIndex = 0;\n  }\n}\n\nfunction generateRandImage() {\n  pg = createGraphics(imageDim, imageDim);\n  pg.colorMode(HSB, 360, 100, 100);\n  pg.loadPixels();\n  waves(pg, wave1, 1);\n  if (doubleWaves) {\n    waves(pg, wave2, 2);\n  }\n  pg.updatePixels();\n}\n\nfunction waves(p, wtype, round) {\n  let speed1 = r.rb(0.00001, 0.0005);\n  let angle1 = 0;\n  let speed2 = r.rb(0.00001, 0.0005);\n  let angle2 = 0;\n  let s = 80.0;\n  let b = 100.0;\n  let wscale = r.rb(0.5, 2.0);\n  \n  let imgIndexTemp = 0;\n\n  p.colorMode(HSB, 360, 100, 100);\n  p.loadPixels();\n  for (let x = 0; x < p.width; x++) {\n    for (let y = 0; y < p.height; y++) {\n      \n      let angle3 = map(y, 0, p.height, 0, TWO_PI*wscale);\n      \n      if (wtype == 1) {\n        let h1 = map(sin(angle1), -1, 1, 0, 1);\n        let h2 = map(sin(angle2+angle3), -1, 1, 0, 1);\n        let hc = (h1 * h2) * 360;\n        if (round == 1) {\n          newImgData[imgIndexTemp] = hc;\n          p.set(x, y, color(hc, s, b));\n        } else { \n          let w = (newImgData[imgIndexTemp] + hc)\/2;\n          newImgData[imgIndexTemp] = w;\n          p.set(x, y, color(w, s, b));\n        }\n      } else if (wtype == 2) {\n        let h1 = map(sin(angle1+angle3), -1, 1, 0, 1);\n        let h2 = map(sin(angle2)+sin(angle3), -1, 1, 0, 1);\n        let hc = (h1 * h2) * 360;\n        if (round == 1) {\n          newImgData[imgIndexTemp] = hc;\n          p.set(x, y, color(hc, s, b));\n        } else {\n          let w = (newImgData[imgIndexTemp] + hc)\/2;\n          newImgData[imgIndexTemp] = w;\n          p.set(x, y, color(w, s, b));\n        }\n      }\n      imgIndexTemp++;\n      angle1 += speed1;\n      angle2 += speed2;\n    }\n  }\n  p.updatePixels();\n}\n\nfunction dots() {\n  let rr = D1\/imageDim;\n  push();\n  translate(A1, B1);\n  scale(rr);\n  rotateY(angle);\n  let yyy = 0;\n  let xx = -imageDim\/2;\n  let yy = -imageDim\/2\n  for (let i = 0; i < imageLength; i += dotsDensity) {\n    stroke(119, 100, 100);\n    if (i % imageDim == 0) {\n      yyy += dotsDensity\/2;\n    }\n    if (i > 0) {\n      point(xx + (i%imageDim), yy + i\/imageDim, newImgData[i] - 180);\n    }\n  }\n  \n  pop();\n  \n  angle += angleSpeed;\n}\n\nfunction signals() {\n  if (height < width) {\n    push();\n    translate(0, B2);\n    stroke(255);\n    strokeWeight(1);\n    for (let i = 0; i < pg.width; i++) {\n      let curr = signalIndex - (i*4);\n      let x = map(i, 0, pg.width, -width \/ 2, width \/ 2);\n      let ry = map(pg.pixels[curr], 0, 255, -signalHeight\/2, signalHeight\/2);\n      let gy = map(pg.pixels[curr+1], 0, 255, -signalHeight\/2, signalHeight\/2);\n      let by = map(pg.pixels[curr+2], 0, 255, -signalHeight\/2, signalHeight\/2);\n      if (i > 0) {\n        point(x*2, ry-signalHeight);\n        point(x*2, gy);\n        point(x*2, by+signalHeight);\n      }\n    }\n    pop();\n  } else {\n    push();\n    translate(A2, 0);\n    stroke(255);\n    strokeWeight(1);\n    for (let i = 0; i < pg.height; i++) {\n      let curr = signalIndex - (i*4);\n      let y = map(i, 0, pg.height, -height \/ 2, height \/ 2);\n      let ry = map(pg.pixels[curr], 0, 255, -signalHeight\/2, signalHeight\/2);\n      let gy = map(pg.pixels[curr+1], 0, 255, -signalHeight\/2, signalHeight\/2);\n      let by = map(pg.pixels[curr+2], 0, 255, -signalHeight\/2, signalHeight\/2);\n      if (i > 0) {\n        point(ry-signalHeight, y*2);\n        point(gy, y*2);\n        point(by+signalHeight, y*2);\n      }\n    }\n    pop();\n  }\n}\n\nfunction blocks() {\n  noStroke();\n  for (let i = 0; i < numBlocks; i+=3) {\n    let idx = (blockIndex + ((numBlocks-1) - i));\n    fill(newImgData[idx], 80, 100);\n    if (width >= height) {\n      xx = map(i, 0, numBlocks, A4, A3);\n      yy = map(i, 0, numBlocks, B4, B3);\n    } else {\n      xx = map(i, 0, numBlocks, A3, A4);\n      yy = map(i, 0, numBlocks, B3, B4);\n    }\n    square(xx, yy, D2);\n  }\n}\n\nfunction setDimensions() {\n  A = width\/2;\n  B = height\/2;\n  ratio = A\/B;\n  \/\/print(ratio);\n  if (width > height) {\n    A1 = A * -0.5625;\n    A2 = A1;\n    A3 = A * 0.1875;\n    A4 = A * 0.5;\n    B1 = B * -0.389;\n    B2 = B * 0.389;\n    B3 = B * 0.278;\n    B4 = B * -0.278;\n    D1 = B * 0.6;\n    D2 = B * 1.1;\n  } else {\n    A1 = A * -0.389;\n    A2 = A * 0.389;\n    A3 = A * -0.278;\n    A4 = A * 0.278;\n    B1 = B * 0.5625;\n    B2 = B1;\n    B3 = B * -0.1873;\n    B4 = B * -0.5;\n    D1 = A * 0.6;\n    D2 = A * 1.1;\n  }\n  if (ratio > 0.8 && ratio < 1.0) {\n    let d = map(ratio, 0.8, 1.0, 1.0, 0.7)\n    D1 = D1 * d;\n    D2 = D2 * d;\n  } else if (ratio >= 1.0 && ratio < 1.2) {\n    let d = map(ratio, 1.0, 1.2, 0.7, 1.0)\n    D1 = D1 * d;\n    D2 = D2 * d;\n  }\n  signalHeight = D1 \/ 4.0;\n}\n\nfunction windowResized() {\n  resizeCanvas(windowWidth, windowHeight);\n  setDimensions();\n}\n\nfunction keyPressed() {\n  if (key == ' ') {\n    generateRandImage();\n  } else if (key == 'b' || key == 'B') {\n    boff += 20;\n    if (boff > 80) {\n      boff = -23;\n    }\n  } else if (key == 's' || key == 'S') {\n    drawSignals = !drawSignals;\n  } else if (key == 't' || key == 'T') {\n    drawDots = !drawDots;\n  } else if (key == 'i' || key == 'I') {\n    drawImage = !drawImage;\n  }\n}\n\nclass RND {\n  constructor(seed) {\n    this.seed = seed;\n  }\n  rd() {\n    this.seed ^= this.seed << 13;\n    this.seed ^= this.seed >> 17;\n    this.seed ^= this.seed << 5;\n    return ((this.seed < 0 ? ~this.seed + 1 : this.seed) % 1000) \/ 1000;\n  }\n  rb(a, b) {\n    return a + (b - a) * this.rd();\n  }\n}"
}