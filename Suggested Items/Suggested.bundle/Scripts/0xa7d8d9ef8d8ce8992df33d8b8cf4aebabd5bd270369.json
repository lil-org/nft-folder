{
  "kind" : "p5js100",
  "screensaverFileName" : "CENTURY.2052",
  "value" : "let seed = parseInt(tokenData.hash.slice(0, 16), 16);  \/\/ ADD FOR LIVE NET\n\nlet r;\nlet maxdim;\nlet fs = new Array(3);\n\nlet bgcolor = 96;\nlet bgdir = -1;\n\nlet dead = false;\nlet checkForDeath = true;\nlet zombie = false;\nlet now;\nlet death;\n\nlet numElements = 0;\nlet strokeDim = 1;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight, WEBGL);\n  colorMode(HSB, 360, 100, 100);\n  pixelDensity(pixelDensity());\n  maxdim = max(width, height);\n  \n  if (maxdim >= 1440) {\n    strokeDim = map(maxdim, 1440, 3160, 1.5, 4.0);\n  } else {\n    strokeDim = map(maxdim, 300, 1440, 0.2, 1.5);\n  }\n\n  numElements = 700;\n  \n  death = new Date(2052, 9, 20, 23, 44, 0, 0);\n  \n  strokeWeight(strokeDim);\n  \n  r = new RND();\n\n  now = Date.now();\n  imdead();\n  newFields();\n  if (dead) {\n    instantDeath();\n  }\n}\n\nfunction draw() {\n  if (checkForDeath && !zombie) {\n    now = Date.now();\n    imdead();\n  }\n  if (dead) {\n    bgcolor -= 0.1;\n    if (bgcolor < 10) {\n      bgcolor = 10;\n    }\n  }\n  background(0, 0, bgcolor);\n  fs[0].display();\n  fs[1].display();\n  fs[2].display();\n}\n\nfunction imdead() {\n  let diff = now - death;\n  if (diff > 0) {\n    dead = true;\n  } else {\n    dead = false;\n  }\n}\n\nfunction instantDeath() {\n  bgcolor = 10;\n  noLoop();\n}\n\nfunction revive() {\n  dead = false;\n  zombie = true;\n  bgcolor = 96;\n  bgdir = -1;\n  fs[0].revive();\n  fs[1].revive();\n  fs[2].revive();\n}\n\nfunction keyPressed() {\n  if (key == ' ') {\n    bgcolor += 5 * bgdir;\n    if (bgcolor >= 100 || bgcolor <= 0) {\n      bgdir *= -1;\n    }\n  } else if (key == 'n' || key == 'N') {\n    newFields();\n  } else if (key == 'd' || key == 'D') {\n    print(now - death);\n  } \n  if (dead) {\n    if (key == 'r' || key == 'R') {\n      revive();\n      loop();\n    }\n  }\n}\n\nfunction newFields() {\n  let ang1 = r.rb(0, TWO_PI);\n  let ang2 = ang1 + r.rb(-QUARTER_PI\/3, QUARTER_PI\/3);\n  let ang3 = ang1 + r.rb(-QUARTER_PI\/3, QUARTER_PI\/3);\n  let d1 = new FieldData(ang1);\n  let d2 = new FieldData(ang2);\n  let d3 = new FieldData(ang3);\n  fs[0] = new Field(d1);\n  fs[1] = new Field(d2);\n  fs[2] = new Field(d3);\n}\n\nclass FieldData {\n  constructor(angle) {\n    this.angle = angle;\n    this.color1 = r.rb(0, 360);\n    this.color2 = r.rb(0, 360);\n    this.whichPalette = r.rb(0, 1);\n    this.speed = r.rb(-0.0005, 0.0005);\n    this.density = r.rb(0.1, 0.4);\n    this.densityTest = new Array(numElements);\n    for (let i = 0; i < this.densityTest.length; i++) {\n      this.densityTest[i] = r.rb(0, 1);\n    }\n  }\n}\n\nclass Element {\n  constructor(_x1, _y1, _x2, _y2, _h, _s, _b, _sp) {\n    this.x1 = _x1;\n    this.y1 = _y1;\n    this.x2 = _x2;\n    this.y2 = _y2;\n    this.off = 0.0;\n    this.h = _h;\n    this.s = _s;\n    this.b = _b;\n    this.supress = _sp;\n    this.deadSaturation = this.s;\n    this.startSaturation = this.s;\n    this.jit = 1.0;\n    if (dead) {\n      this.jit = 0.0;\n      this.deadSaturation = 0.0;\n    }\n  }\n  \n  revive() {\n    this.jit = 1.0;\n    this.deadSaturation = this.startSaturation;\n  }\n\n  jitter() {\n    if (dead) {\n      this.jit -= 0.001;\n      if (this.jit <= 0) {\n        this.jit = 0;\n      }\n    }\n    this.off = r.rb(-this.jit, this.jit);\n  }\n\n  display() {\n    if (dead) {\n      this.deadSaturation -= 0.1;\n      if (this.deadSaturation <= 0) {\n        this.deadSaturation = 0;\n      }\n    }\n    if (!this.supress) {\n      if (dead) {\n        stroke(this.h, this.deadSaturation, this.b);\n      } else {\n        stroke(this.h, this.s, this.b);\n      }\n      line(this.x1 + this.off, this.y1, this.x2 + this.off, this.y2);\n    }\n  }\n}\n\nclass Field {\n  constructor(fd) {\n    this.num = numElements;\n    this.angle = fd.angle;\n    this.speed = fd.speed;\n    this.density = fd.density;\n    this.densityTest = fd.densityTest;\n    this.whichPalette = fd.whichPalette;\n    this.color1 = fd.color1;\n    this.color2 = fd.color2;\n    this.count = 0;\n    this.elements = [this.num];\n    this.show = true;\n    this.pnums = [];\n    this.rndColor = 0;\n    this.createColor();\n    let index = 0;\n    for (let i = 0; i < numElements; i++) {\n      let tx = map(i, 0, numElements - 1, -maxdim, maxdim); \/\/ ALT\n      let h = this.pnums[index];\n      let s = this.pnums[index + 1];\n      let b = this.pnums[index + 2];\n      this.elements[i] = new Element(\n        tx,\n        -maxdim,\n        tx,\n        maxdim,\n        h,\n        s,\n        b,\n        this.show\n      );\n      index += 3;\n      if (this.densityTest[i] > this.density) {\n        this.show = false;\n      } else {\n        this.show = true;\n      }\n    }\n  }\n  \n  revive() {\n    for (let i = 0; i < numElements; i++) {\n      this.elements[i].revive(); \n    }\n  }\n\n  display() {\n    push();\n    rotate(this.angle);\n    for (let i = 0; i < numElements; i++) {\n      this.elements[i].jitter();\n      this.elements[i].display();\n    }\n    if (!dead) {\n      this.angle += this.speed;\n    }\n    pop();\n  }\n\n  createColor() {\n    if (this.whichPalette > 0.66) {\n      this.rndColor = 1;\n    } else {\n      this.rndColor = 0;\n    }\n    this.createPalette();\n  }\n  \n  createPalette() {\n    let index = 0;\n    let start = this.color1;\n    let microStart = this.color2;\n    for (let x = 0; x < numElements; x++) {\n      if (this.rndColor == 0) {\n        let xx = map(x, 0, numElements, 0, 720);\n        let h = map(x, 0, numElements, start, (start + xx) % 360);\n        let s = map(x, 0, numElements, 30, 90);\n        let b = 85;\n        this.pnums[index] = h;\n        this.pnums[index + 1] = s;\n        this.pnums[index + 2] = b;\n        index += 3;\n      } else if (this.rndColor == 1) {\n        let stop = start + map(x, 0, numElements, 0, 360);\n        if (stop > 360) {\n          stop = stop - 360;\n        }\n        this.pnums[index] = stop;\n        this.pnums[index + 1] = map(x, 0, numElements, 30, 90);\n        this.pnums[index + 2] = 85;\n        index += 3;\n      }\n    }\n  }\n}\n\nclass RND {\n  constructor() {\n    this.useA = false;\n    let sfc32 = function (uint128Hex) {\n      let a = parseInt(uint128Hex.substr(0, 8), 16);\n      let b = parseInt(uint128Hex.substr(8, 8), 16);\n      let c = parseInt(uint128Hex.substr(16, 8), 16);\n      let d = parseInt(uint128Hex.substr(24, 8), 16);\n      return function () {\n        a |= 0; b |= 0; c |= 0; d |= 0;\n        let t = (((a + b) | 0) + d) | 0;\n        d = (d + 1) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        c = (c + t) | 0;\n        return (t >>> 0) \/ 4294967296;\n      };\n    };\n    this.prngA = new sfc32(tokenData.hash.substr(2, 32));\n    this.prngB = new sfc32(tokenData.hash.substr(34, 32));\n    for (let i = 0; i < 1e6; i += 2) {\n      this.prngA();\n      this.prngB();\n    }\n  }\n  random_dec() {\n    this.useA = !this.useA;\n    return this.useA ? this.prngA() : this.prngB();\n  }\n  rb(a, b) {\n    return a + (b - a) * this.random_dec();\n  }\n}"
}