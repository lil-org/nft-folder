{
  "contractAddress" : "0x294fed5f1d3d30cfa6fe86a937dc3141eec8bc6d",
  "kind" : "p5js100",
  "projectId" : "1",
  "screensaverFileName" : "ATOMS",
  "script" : "var seed = parseInt(tokenData.hash.slice(0, 16), 16);\n\np5.disableFriendlyErrors = true;\n\nlet pg;\n\nlet A, B;\nlet A1, A2, A3, A4;\nlet B1, B2, B3, B4;\nlet D1, D2;\n\nlet xx, yy;\n\nlet imageDim = 400;\nlet imageLength = imageDim * imageDim;\nlet signalHeight;\nlet numBlocks = imageDim\/4;\n\nlet lastBlockTime = 0;\nlet blockDelay = 375;\n\nlet dotsDensity = 36;\n\nlet signalIndex = imageDim * 4;\nlet blockIndex = 0;\n\nlet drawSignals = true;\nlet drawImage = true;\nlet drawBlocks = true;\nlet drawDots = true;\n\nlet angle = 0.0;\nlet angleSpeed = 0.01;\n\nlet newImgData = [];\n\nlet boff = 0;\n\nlet ratio = 0.0;\n\n\/\/ Features\nlet weirdo = false;\nlet doubleWaves = false;\nlet wave1 = -1;\nlet wave2 = -1;\n\nfunction setup() {\n  createCanvas(windowWidth, windowHeight, WEBGL);\n  colorMode(HSB, 360, 100, 100);\n  \n  r = new RND(seed);\n  \n  \/\/ BEGIN features\n  if (r.rb(0, 1) > 0.95) {\n    weirdo = true;\n  }\n  if (r.rb(0, 1) > 0.6) {\n    doubleWaves = true;\n  }\n  wave1 = int(r.rb(1, 3));\n  wave2 = int(r.rb(1, 3));\n  \/\/ END features\n  \n  generateRandImage();\n  rectMode(CENTER);\n  imageMode(CENTER);\n  setDimensions();\n  frameRate(30);\n}\n\nfunction draw() {\n  if (weirdo) {\n    background(newImgData[blockIndex], 80, 100);\n  } else {\n    background(6, 15, 23+boff);\n  }\n\n  if (drawBlocks) { blocks(); }\n  if (drawSignals) { signals(); }\n  if (drawDots) { dots(); }\n  \n  if (drawImage) {\n    image(pg, A2, B2, D1, D1);\n  }\n  signalIndex += 4;\n  blockIndex += 2;\n  if (signalIndex > pg.pixels.length) {\n    signalIndex = imageDim * 4;\n  }\n  if (blockIndex > newImgData.length) {\n    blockIndex = 0;\n  }\n}\n\nfunction generateRandImage() {\n  pg = createGraphics(imageDim, imageDim);\n  pg.colorMode(HSB, 360, 100, 100);\n  pg.loadPixels();\n  waves(pg, wave1, 1);\n  if (doubleWaves) {\n    waves(pg, wave2, 2);\n  }\n  pg.updatePixels();\n}\n\nfunction waves(p, wtype, round) {\n  let speed1 = r.rb(0.00001, 0.0005);\n  let angle1 = 0;\n  let speed2 = r.rb(0.00001, 0.0005);\n  let angle2 = 0;\n  let s = 80.0;\n  let b = 100.0;\n  let wscale = r.rb(0.5, 2.0);\n  \n  let imgIndexTemp = 0;\n\n  p.colorMode(HSB, 360, 100, 100);\n  p.loadPixels();\n  for (let x = 0; x < p.width; x++) {\n    for (let y = 0; y < p.height; y++) {\n      \n      let angle3 = map(y, 0, p.height, 0, TWO_PI*wscale);\n      \n      if (wtype == 1) {\n        let h1 = map(sin(angle1), -1, 1, 0, 1);\n        let h2 = map(sin(angle2+angle3), -1, 1, 0, 1);\n        let hc = (h1 * h2) * 360;\n        if (round == 1) {\n          newImgData[imgIndexTemp] = hc;\n          p.set(x, y, color(hc, s, b));\n        } else { \n          let w = (newImgData[imgIndexTemp] + hc)\/2;\n          newImgData[imgIndexTemp] = w;\n          p.set(x, y, color(w, s, b));\n        }\n      } else if (wtype == 2) {\n        let h1 = map(sin(angle1+angle3), -1, 1, 0, 1);\n        let h2 = map(sin(angle2)+sin(angle3), -1, 1, 0, 1);\n        let hc = (h1 * h2) * 360;\n        if (round == 1) {\n          newImgData[imgIndexTemp] = hc;\n          p.set(x, y, color(hc, s, b));\n        } else {\n          let w = (newImgData[imgIndexTemp] + hc)\/2;\n          newImgData[imgIndexTemp] = w;\n          p.set(x, y, color(w, s, b));\n        }\n      }\n      imgIndexTemp++;\n      angle1 += speed1;\n      angle2 += speed2;\n    }\n  }\n  p.updatePixels();\n}\n\nfunction dots() {\n  let rr = D1\/imageDim;\n  push();\n  translate(A1, B1);\n  scale(rr);\n  rotateY(angle);\n  let yyy = 0;\n  let xx = -imageDim\/2;\n  let yy = -imageDim\/2\n  for (let i = 0; i < imageLength; i += dotsDensity) {\n    stroke(119, 100, 100);\n    if (i % imageDim == 0) {\n      yyy += dotsDensity\/2;\n    }\n    if (i > 0) {\n      point(xx + (i%imageDim), yy + i\/imageDim, newImgData[i] - 180);\n    }\n  }\n  \n  pop();\n  \n  angle += angleSpeed;\n}\n\nfunction signals() {\n  if (height < width) {\n    push();\n    translate(0, B2);\n    stroke(255);\n    strokeWeight(1);\n    for (let i = 0; i < pg.width; i++) {\n      let curr = signalIndex - (i*4);\n      let x = map(i, 0, pg.width, -width \/ 2, width \/ 2);\n      let ry = map(pg.pixels[curr], 0, 255, -signalHeight\/2, signalHeight\/2);\n      let gy = map(pg.pixels[curr+1], 0, 255, -signalHeight\/2, signalHeight\/2);\n      let by = map(pg.pixels[curr+2], 0, 255, -signalHeight\/2, signalHeight\/2);\n      if (i > 0) {\n        point(x*2, ry-signalHeight);\n        point(x*2, gy);\n        point(x*2, by+signalHeight);\n      }\n    }\n    pop();\n  } else {\n    push();\n    translate(A2, 0);\n    stroke(255);\n    strokeWeight(1);\n    for (let i = 0; i < pg.height; i++) {\n      let curr = signalIndex - (i*4);\n      let y = map(i, 0, pg.height, -height \/ 2, height \/ 2);\n      let ry = map(pg.pixels[curr], 0, 255, -signalHeight\/2, signalHeight\/2);\n      let gy = map(pg.pixels[curr+1], 0, 255, -signalHeight\/2, signalHeight\/2);\n      let by = map(pg.pixels[curr+2], 0, 255, -signalHeight\/2, signalHeight\/2);\n      if (i > 0) {\n        point(ry-signalHeight, y*2);\n        point(gy, y*2);\n        point(by+signalHeight, y*2);\n      }\n    }\n    pop();\n  }\n}\n\nfunction blocks() {\n  noStroke();\n  for (let i = 0; i < numBlocks; i+=3) {\n    let idx = (blockIndex + ((numBlocks-1) - i));\n    fill(newImgData[idx], 80, 100);\n    if (width >= height) {\n      xx = map(i, 0, numBlocks, A4, A3);\n      yy = map(i, 0, numBlocks, B4, B3);\n    } else {\n      xx = map(i, 0, numBlocks, A3, A4);\n      yy = map(i, 0, numBlocks, B3, B4);\n    }\n    square(xx, yy, D2);\n  }\n}\n\nfunction setDimensions() {\n  A = width\/2;\n  B = height\/2;\n  ratio = A\/B;\n  \/\/print(ratio);\n  if (width > height) {\n    A1 = A * -0.5625;\n    A2 = A1;\n    A3 = A * 0.1875;\n    A4 = A * 0.5;\n    B1 = B * -0.389;\n    B2 = B * 0.389;\n    B3 = B * 0.278;\n    B4 = B * -0.278;\n    D1 = B * 0.6;\n    D2 = B * 1.1;\n  } else {\n    A1 = A * -0.389;\n    A2 = A * 0.389;\n    A3 = A * -0.278;\n    A4 = A * 0.278;\n    B1 = B * 0.5625;\n    B2 = B1;\n    B3 = B * -0.1873;\n    B4 = B * -0.5;\n    D1 = A * 0.6;\n    D2 = A * 1.1;\n  }\n  if (ratio > 0.8 && ratio < 1.0) {\n    let d = map(ratio, 0.8, 1.0, 1.0, 0.7)\n    D1 = D1 * d;\n    D2 = D2 * d;\n  } else if (ratio >= 1.0 && ratio < 1.2) {\n    let d = map(ratio, 1.0, 1.2, 0.7, 1.0)\n    D1 = D1 * d;\n    D2 = D2 * d;\n  }\n  signalHeight = D1 \/ 4.0;\n}\n\nfunction windowResized() {\n  resizeCanvas(windowWidth, windowHeight);\n  setDimensions();\n}\n\nfunction keyPressed() {\n  if (key == ' ') {\n    generateRandImage();\n  } else if (key == 'b' || key == 'B') {\n    boff += 20;\n    if (boff > 80) {\n      boff = -23;\n    }\n  } else if (key == 's' || key == 'S') {\n    drawSignals = !drawSignals;\n  } else if (key == 't' || key == 'T') {\n    drawDots = !drawDots;\n  } else if (key == 'i' || key == 'I') {\n    drawImage = !drawImage;\n  }\n}\n\nclass RND {\n  constructor(seed) {\n    this.seed = seed;\n  }\n  rd() {\n    this.seed ^= this.seed << 13;\n    this.seed ^= this.seed >> 17;\n    this.seed ^= this.seed << 5;\n    return ((this.seed < 0 ? ~this.seed + 1 : this.seed) % 1000) \/ 1000;\n  }\n  rb(a, b) {\n    return a + (b - a) * this.rd();\n  }\n}",
  "tokens" : [
    {
      "hash" : "0x0299c23711940b2538d2a54c43d2485314fe6283849afd6f8419502f42d84384",
      "id" : "1000027"
    },
    {
      "hash" : "0xa929b5bb581ff031237223e0925ac3191c59ee6032b441e23706424a0525c5d6",
      "id" : "1000016"
    },
    {
      "hash" : "0x9605853f964440424e334537b961e236ceea3c3aa71127e0594cf0f2ee544c4c",
      "id" : "1000036"
    },
    {
      "hash" : "0x187334ea8589bfbcd6007d22b33b4595ee604ed33fcc66ef0f2cb8b5dd5b301e",
      "id" : "1000007"
    },
    {
      "hash" : "0x4b280e9da96ae145428c19b4d5e4e1b77c9eb6a6a08bcd8165b9fec27344c296",
      "id" : "1000026"
    },
    {
      "hash" : "0x531df83d7293244e8c88a67a1b13a2e9a2a042ad521b95e3456e50e95cdbe949",
      "id" : "1000001"
    },
    {
      "hash" : "0x9553da93e40cd4b022b0bfd4132d0c11f9b4f7b046776c843f5ac93ea2296584",
      "id" : "1000021"
    },
    {
      "hash" : "0x6500c9f46c75e1a12b7ea924373dd47b6961fc54d30f3d6264b01f17f954f6d9",
      "id" : "1000004"
    },
    {
      "hash" : "0x9216c74d6890e0a89cc935ef5c03e5c722242b5382573a582ddfbd5b4e4fdf7b",
      "id" : "1000022"
    },
    {
      "hash" : "0xf7296c65e590b46bfba0ab8caf6822882cb81c7d5f94efc0db9d13c9dc616706",
      "id" : "1000012"
    },
    {
      "hash" : "0x67b6fb320e14850b61cfbcef7acd09abea5e350b17e708d28fe01cf05db4fd0f",
      "id" : "1000024"
    },
    {
      "hash" : "0xf4721cd4993c7780dd17663afac1e426342e5b4ae66b6da010b8bfefce5bed27",
      "id" : "1000010"
    },
    {
      "hash" : "0x49e11f234975cebb07d81525bdb6984173ffc07ec103a5f1ee76542f18d4235d",
      "id" : "1000031"
    },
    {
      "hash" : "0xc13941bb5891899a377d3e609cef32bf802c686bd4f42ab2e5bcaaab3a4a3bc3",
      "id" : "1000030"
    },
    {
      "hash" : "0xee10d032f18bc884c63fb836dd4b998bb43a8bf3435c68b2088d29538c200afd",
      "id" : "1000025"
    },
    {
      "hash" : "0xf21cc246c8bb6d79eb6b88ae20a6a98825c5d622c011b60023a8b00621147468",
      "id" : "1000023"
    },
    {
      "hash" : "0x8d9dd2a0ddd61f39bc83aa6924ea7aa12e2c8add07162062d6de8462f148a089",
      "id" : "1000020"
    },
    {
      "hash" : "0x5bc4a21b354b01c84aff2f5e75149ba8c7256bfd21d20a967f8708b0751f616a",
      "id" : "1000011"
    },
    {
      "hash" : "0x3e41ee2c6ddf9b819257661e89b73b80bb531c5598483fd874311fabbc6c9f6d",
      "id" : "1000017"
    },
    {
      "hash" : "0x223f0be1405d767ba247b534d08bba2f51f005cda8a8a3a2e16ee1fd06e52ccd",
      "id" : "1000005"
    },
    {
      "hash" : "0x20638a35164b89f788747ca3b3c03784b38d5bc4b92f926354665a506c35980c",
      "id" : "1000028"
    },
    {
      "hash" : "0xa1e69998303ad7754e889beade95e216781228c1c9f57bdcad68912d7a5b9df3",
      "id" : "1000002"
    },
    {
      "hash" : "0x3471a7f753180984664aea6c35e441d407ac191095974d8f1d2db006901a5784",
      "id" : "1000015"
    },
    {
      "hash" : "0xfa2057c58f4e48c00424a9fbfcf725fa3e5210778a7a65132b3091a1e70feb4c",
      "id" : "1000014"
    },
    {
      "hash" : "0x0cf2a22116a5ff25a331c219a8e15766d6e5a728f8b1bbbc6c568d4c75d23796",
      "id" : "1000018"
    },
    {
      "hash" : "0xff8dd245d6ccb23312271de96e8041d5311c5f18d43d520d827f441ec9054261",
      "id" : "1000037"
    },
    {
      "hash" : "0xdc7cb7b8af8f22179187650fd2e9c7c84c076defa1f5c804734d7a42a5c36d7b",
      "id" : "1000000"
    },
    {
      "hash" : "0xd3af0266b1b3ef4918929e5c7845f89baf83458236a66b87b2f4ab963ce412d4",
      "id" : "1000013"
    },
    {
      "hash" : "0xfddc5487c2f913595d521bd89fe3b84a7a2f01f6b1717cb34c81797caabed90e",
      "id" : "1000003"
    },
    {
      "hash" : "0x31fdcee75c1dc5e3d1f4312ae131383d2625c85c06908cae4e5fa1d2a1f5879a",
      "id" : "1000009"
    },
    {
      "hash" : "0xfe92d63af92e9fd6847cb228c813047497370a736e30b71cea020607930dcbec",
      "id" : "1000029"
    },
    {
      "hash" : "0x06de9f2f2fcff8df3801e893b08eaadb01ee67b204ec7c3cae9cd9f908369c48",
      "id" : "1000008"
    },
    {
      "hash" : "0x4f478073e077fb800d3a8fdf5c3f83b4435c49d7a273fa550f0d31237e672fdc",
      "id" : "1000032"
    },
    {
      "hash" : "0x7e8f39670d5f67b015b5584ccbbeea1f40974b19313daf91f8915c295c06c9e8",
      "id" : "1000034"
    },
    {
      "hash" : "0x15804491c8654618c27f705c5e97187d87ee7ef7c315f253545507340940e14c",
      "id" : "1000035"
    },
    {
      "hash" : "0x3b36da5c3d86cb9adc8ba0106085e614d142b4ca9ab770bb1735da20625a2645",
      "id" : "1000033"
    },
    {
      "hash" : "0xf087093bf28bd363cac26c7c42bd46063fc01d7fbb820bb9992e0fd4161ff65c",
      "id" : "1000006"
    },
    {
      "hash" : "0x3eca0cc93331cd0a43f7ce25a93e2a7467996919e3c8b508ed42c69c126f53c4",
      "id" : "1000019"
    }
  ]
}