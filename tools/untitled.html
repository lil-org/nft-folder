<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
    <meta charset="utf-8"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.0.0/p5.min.js"></script>
    <script>
    let tokenData = {
        "tokenId": "114000424",
        "hash": "0x710e58f1a85051eb392ff157f7118f46cb6313708e2202644c9b3e3278e8a517"
    }
    </script>
    <script>
    let bgc = ["#000000", "#000000", "#000000", "#ff6600", "#cc99ff", "#ffcc33", "#ffcccc", "#ff0000", "#0000ff", "#000c66", "#ff4500", "#741aac", "#535bf6", "#43b0f1", "#333333", "#ffffff", "#ffffff", "#ffffff"],
        objc = ["#ff6600", "#cc99ff", "#ffcc33", "#ff0000", "#0000ff", "#000c66", "#ff4500", "#741aac", "#535bf6", "#333333"],
        rP = sPFTD(tokenData),
        params = {
            shp: rP[0] < 127,
            bgCS: parseInt(mapParam(rP[1], 0, bgc.length - 1)),
            objCS: parseInt(mapParam(rP[2], 0, objc.length - 1)),
            objCLT: parseInt(mapParam(rP[3], 0, objc.length - 1)),
            wf: rP[4] < 127,
            gM: rP[5] < 85,
            cMA: rP[6] < 127,
            cMB: rP[7] < 127,
            cDA: rP[8] < 127,
            cDB: rP[9] < 127,
            cF: rP[10] < 0,
            inv: rP[11] < 127,
            trM: rP[12] < 127,
            rXM: parseInt(mapParam(rP[13], 0, 4)),
            rYM: parseInt(mapParam(rP[14], 0, 4)),
            rZM: parseInt(mapParam(rP[15], 0, 4)),
            trXM: parseInt(mapParam(rP[16], 0, 4)),
            trYM: parseInt(mapParam(rP[17], 0, 4)),
            trZM: parseInt(mapParam(rP[18], 0, 4)),
            frame: parseInt(mapParam(rP[19], 0, 1e3)),
            num: parseInt(mapParam(rP[20], 24, 64)),
            rotX: mapParam(rP[21], -.005, .005),
            rotY: mapParam(rP[22], -.005, .005),
            rotZ: mapParam(rP[23], -.005, .005)
        };
    const D_S = 1e3;
    let W = window.innerWidth,
        H = window.innerHeight,
        DIM = Math.min(W, H),
        M = DIM / D_S,
        num = params.num;
    const aT3 = 93.3098,
        tT3 = .998332;
    function setup() {
        createCanvas(DIM, DIM, WEBGL),
        smooth(),
        noCursor(),
        strokeWeight(M),
        params.objCS == params.objCLT && (params.objCLT += 1, params.objCLT >= objc.length - 1 && (params.objCLT = 0)),
        frameCount = Math.floor(params.frame)
    }
    function dVT(a, r) {
        let t = Math.PI / 180 * aT3;
        if (params.shp) {
            push(),
            rotateX(-Math.PI / 2);
            for (var n = 0; n < 3; n++)
                push(),
                rotateZ(2 * Math.PI / 3 * n),
                push(),
                rotateX(t),
                triangle(0, 0, -a / 10, r, a / 10, r),
                pop(),
                translate(0, 0, 2 * r * tT3),
                push(),
                rotateX(-t),
                triangle(0, 0, -a / 10, r, a / 10, r),
                pop(),
                pop();
            pop()
        } else {
            push(),
            rotateX(-Math.PI / 2);
            for (n = 0; n < 3; n++)
                push(),
                rotateZ(2 * Math.PI / 3 * n),
                push(),
                rotateX(t),
                triangle(0, 0, -r / 10, a, r / 10, a),
                pop(),
                translate(0, 0, 2 * a * tT3),
                push(),
                rotateX(-t),
                triangle(0, 0, -r / 10, a, r / 10, a),
                pop(),
                pop();
            pop()
        }
    }
    function draw() {
        let a = bgc[params.bgCS];
        background(a),
        params.gM && (a = 0, params.inv && (a = 255), background(a)),
        shininess(31),
        specularColor(255),
        specularMaterial(255);
        let r = 255,
            t = DIM,
            n = DIM,
            e = DIM,
            s = createVector(t, n, e),
            m = createVector(-t, -n, e),
            o = createVector(t, -n, -e);
        s.normalize(),
        m.normalize(),
        o.normalize(),
        ambientLight(127),
        directionalLight(255, 255, 255, s),
        pointLight(r, r, r, s),
        pointLight(r, r, r, m),
        pointLight(r, r, r, o),
        push(),
        rotateX(Math.sin(frameCount * params.rotX) * Math.PI / 10),
        rotateY(Math.sin(frameCount * params.rotY) * Math.PI / 10),
        rotateZ(frameCount * params.rotZ);
        for (let r = 0; r < num; r++) {
            let t = r / num * 255,
                n = r / num * 255 * (1.7 * M),
                e = Math.sin(.01 * frameCount + .1 * r) * DIM / 4;
            push(),
            noStroke();
            let s = DIM / 10,
                m = .05,
                o = Math.sin((frameCount + r * Math.PI) * m) * s,
                p = Math.sin((frameCount + r * Math.PI / 2) * m) * s;
            if (params.trM ? translate((r / num - .5) * DIM, o, p) : translate((r / num - .5) * DIM / 10, 0, 0), 1 == params.rXM ? rotateX(.1 * r) : 2 == params.rXM ? rotateX(r / num * Math.PI * 2) : 3 == params.rXM && rotateX(r / num * Math.PI * 4), 1 == params.rYM ? rotateY(.1 * r) : 2 == params.rYM ? rotateY(r / num * Math.PI * 2) : 3 == params.rYM && rotateY(r / num * Math.PI * 4), 1 == params.rZM ? rotateZ(.1 * r) : 2 == params.rZM ? rotateZ(r / num * Math.PI * 2) : 3 == params.rZM && rotateZ(r / num * Math.PI * 4), (0 == params.rXM || params.rXM >= 4) && (0 == params.rZM || params.rZM >= 4) && rotateZ(.1 * r), 1 == params.trXM ? translate(Math.sin(frameCount * m * .01) * s, 0, 0) : 2 == params.trXM ? translate(Math.sin((frameCount + 1 * r) * m * .1) * s, 0, 0) : 3 == params.trXM && translate(Math.sin((frameCount + 10 * r) * m * .1) * s, 0, 0), 1 == params.trYM ? translate(0, Math.sin(frameCount * m * .01) * s, 0) : 2 == params.trYM ? translate(0, Math.sin((frameCount + 1 * r) * m * .1) * s, 0) : 3 == params.trYM && translate(0, Math.sin((frameCount + 10 * r) * m * .1) * s, 0), 1 == params.trZM ? translate(0, 0, Math.sin(frameCount * m * .01) * s) : 2 == params.trZM ? translate(0, 0, Math.sin((frameCount + 1 * r) * m * .1) * s) : 3 == params.trZM && translate(0, 0, Math.sin((frameCount + 10 * r) * m * .1) * s), params.cMA ? params.cMB ? params.cDA ? fill(0, t, 255, 255) : fill(0, 255 - t, 255, 255) : params.cDA ? fill(t, 0, 255, 255) : fill(255 - t, 0, 255, 255) : params.cMB ? params.cDB ? fill(255, t, 0, 255) : fill(255, 255 - t, 0, 255) : params.cDB ? fill(255, 0, t, 255) : fill(255, 0, 255 - t, 255), params.cF) {
                let a = color(objc[params.objCS]),
                    t = color(objc[params.objCLT]),
                    n = lerpColor(a, t, r / num);
                fill(n)
            }
            params.gM && (params.cDB ? fill(t, t, t, 255) : fill(255 - t, 255 - t, 255 - t, 255)),
            noStroke(),
            dVT(e, -e),
            dVT(e, e),
            push(),
            noFill(),
            lightness(a) <= 50 ? stroke(255, 255) : stroke(0, 255),
            dVT(n, -n),
            dVT(n, n),
            pop(),
            pop()
        }
        pop()
    }
    function windowResized() {
        W = window.innerWidth,
        H = window.innerHeight,
        DIM = Math.min(W, H),
        M = DIM / D_S,
        resizeCanvas(DIM, DIM, WEBGL),
        strokeWeight(M)
    }
    function sPFTD(a) {
        let r = [];
        for (let t = 0; t < 32; t++)
            r.push(a.hash.slice(2 + 2 * t, 4 + 2 * t));
        return r.map(a => parseInt(a, 16))
    }
    function mapd(a, r, t, n, e) {
        return (a - r) / (t - r) * (e - n) + n
    }
    function mapParam(a, r, t) {
        return mapd(a, 0, 255, r, t)
    }
    </script>
    <style type="text/css">
    html {
        height: 100%;
    }

    body {
        min-height: 100%;
        margin: 0;
        padding: 0;
    }

    canvas {
        padding: 0;
        margin: auto;
        display: block;
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
    }
    </style>
</head>
</html>
